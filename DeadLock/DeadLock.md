# DeadLock
***
1. 死锁运行情况
    * 当count值为20000时：
        ![pic1](https://raw.githubusercontent.com/Ljl-alone/ES2016_14353197/master/DeadLock%E5%9B%BE%E7%89%871.png)
    * 当count值为10000时：
        ![pic2](https://raw.githubusercontent.com/Ljl-alone/ES2016_14353197/master/DeadLock%E5%9B%BE%E7%89%872.png)
2. 产生死锁的4个必要条件
    1. 互斥条件：一个资源每次只能被一个进程使用
    2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
    3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺
    4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系
3. 对上述程序产生死锁的解释
      * 在实验的代码中，当t.start()执行后，线程t就被插入到调度队列中，当线程t被调度到执行的时候，就开始执行run()里面的代码，即b.methodB(a),而在等待count的时间后a.methodA(b)也开始执行了，当这两句同时执行时，由于执行顺序就很容易进入到相同的代码块中，但是synchronized关键字又保证在同一时刻最多只有一个线程执行该段代码。所以就可能发生线程b就在等进入到该代码块的线程a从某个函数（比如说last）出来（释放锁），而线程a执行时想获得线程b占有的锁（另一个函数中），这样两个都在等对方持有的锁最终就导致了死锁，谁都执行不了。
